#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define ld long double
#define ull unsigned long long
#define pii pair<int,int>
#define pll pair<ll,ll>
#define vi vector<int>
#define vll vector<ll>
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define fi first
#define se second
#define endl "\n"
#define YES cout << "YES\n"
#define NO cout << "NO\n"

const ll MOD = 1000000007LL;
const ll MOD2 = 998244353LL;
const ll INF = 1e18;
const int N = 200005;

void fastio() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
}

ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }

ll modpow(ll a, ll b, ll m = MOD) {
    ll res = 1;
    a %= m;
    while (b > 0) {
        if (b & 1) res = (res * a) % m;
        a = (a * a) % m;
        b >>= 1;
    }
    return res;
}

ll modinv(ll a, ll m = MOD) { return modpow(a, m - 2, m); }

bool isprime(ll n) {
    if (n < 2) return false;
    for (ll i = 2; i * i <= n; i++)
        if (n % i == 0) return false;
    return true;
}

vector<bool> sieve(int n) {
    vector<bool> is_prime(n+1,true);
    if (n >= 0) is_prime[0] = false;
    if (n >= 1) is_prime[1] = false;
    for (int i = 2; i * i <= n; i++)
        if (is_prime[i])
            for (int j = i * i; j <= n; j += i)
                is_prime[j] = false;
    return is_prime;
}

vector<pair<ll,int>> prime_factors(ll n) {
    vector<pair<ll,int>> res;
    for (ll i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            int cnt = 0;
            while(n % i == 0) n/=i, cnt++;
            res.push_back({i, cnt});
        }
    }
    if (n > 1) res.push_back({n, 1});
    return res;
}

ll phi(ll n) {
    ll res = n;
    for (ll i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            while(n % i == 0) n/=i;
            res -= res / i;
        }
    }
    if (n > 1) res -= res / n;
    return res;
}

ll binpow(ll a, ll b) {
    ll res = 1;
    while (b > 0) {
        if (b & 1) res *= a;
        a *= a;
        b >>= 1;
    }
    return res;
}

vector<ll> fact, invfact;

void init_combi(int n, ll mod = MOD) {
    fact.assign(n+1,1);
    invfact.assign(n+1,1);
    for (int i = 1; i <= n; i++) fact[i] = fact[i-1] * i % mod;
    invfact[n] = modinv(fact[n], mod);
    for (int i = n-1; i >= 0; i--) invfact[i] = invfact[i+1] * (i+1) % mod;
}

ll nCr(int n, int r, ll mod = MOD) {
    if (r < 0 || r > n) return 0;
    return fact[n] * invfact[r] % mod * invfact[n-r] % mod;
}

template<class T>
T first_true(function<bool(T)> f, T lo, T hi) {
    while (lo < hi) {
        T mid = lo + (hi - lo) / 2;
        if (f(mid)) hi = mid;
        else lo = mid + 1;
    }
    return lo;
}

template<class T>
T last_true(function<bool(T)> f, T lo, T hi) {
    while (lo < hi) {
        T mid = lo + (hi - lo + 1) / 2;
        if (f(mid)) lo = mid;
        else hi = mid - 1;
    }
    return lo;
}

void solve() {
    ll n;
    cin >> n;
    vector<ll> a(n);
}

int main() {
    fastio();
    int t = 1;
    if (!(cin >> t)) return 0;
    while (t--) solve();
    return 0;
}
